#!/bin/bash

# Executable preamble
mydir="$(dirname $0)"
pushd "$mydir/.." > /dev/null; dotfun="$(pwd)"; popd > /dev/null
funlib="${dotfun}/lib"
dotfiles="${dotfun}"
[[ -d "$dotfun/../dotfiles" ]] && dotfiles="$dotfun/../dotfiles"
libdir="${dotfiles}/lib"

# Imports
. "${libdir}/Lib.sh"
. "${libdir}/Module.sh"
. "${libdir}/CLI.sh"
. "${libdir}/Git.sh"
. "${libdir}/Branch.sh"
. "${libdir}/Assembly.sh"
. "${funlib}/Fundle.sh"

# Parsed options
GIT_PARSEOPT_SPEC="\
git-funfetti [options] CHIP [-- [BOOT-ARG BOOT-ARG ...]]

Fun-on-demand driver which automates the process of building a DPU firmware \
bundle for the specified CHIP with the firmware components specified by the \
user. The following FIRMWAREs may be given as arguments to the f,firmware \
option:

    FunOS          The main FunOS image
    FunSDK-small   The minimal FunOS SDK required to build FunOS

Firmwares may be built for different platforms, and by default they are built \
for physical SoCs. The following PLATFORMs may be given as arguments to the \
p,platform option:

    soc       The physical SoC target
    posix     The POSIX simulator target
    qemu      The QEMU emulator platform
    emu       The Palladium FPGA platform

Images may be built as different variants, and by default, the debug variants \
are built. The following VARIANTs may be given as arguments to the v,variant \
option:

    release      Omits virtually all debugging functionality
    noasan       Similar to debug, except that the Address Sanitizer is disabled
    debug        Includes all debugging functionality

$(CLI.get_stuckopt_blurb)
--
 Available options
f,firmware=FIRMWARE[@BASE]   A firmware image to build. This may be specified \
multiple times, in which case several images are built and deployed to \
fun-on-demand. If a BASE is included in the argument, that ref of the project \
is used as the merge base, otherwise the default branch is used as the merge \
base. Firmwares are built in the order specified on the command line

b,branch=FIRMWARE:BRANCH-NAME A branch to merge into FIRMWARE before building. \
This option may be specified multiple times, in which case the branches are \
merged in the order specified

T,shared-base-tag=BASE-TAG    Use BASE-TAG as the merge base for all firmware \
builds. This is useful if all projects are aligned on tag numbers. This option \
will only affect firmwares which did not explicitly specify a base tag

F,current-firmware            Infer the firmware, branch, and base tag to use \
from the current git repository. The firmware name is derived from the base \
name of the repository remote URL, the branch is inferred from the currently \
checked out branch, and the base tag is derived from the first ancestor tag of \
the current branch and is used as though it was given to the T,shared-base-tag \
option

p,platform=PLATFORM           The platform to build for. If unspecified, \
images are built for physical SoC targets

V,variant=VARIANT             The variant to build

n,cluster-number=NUMBER       The specific fun-on-demand server to connect to \
for operations. If unspecified, one is chosen at random

m,email-address=EMAIL-ADDRESS Add EMAIL-ADDRESS to the list of email addresses \
that should receive status updates for the job. This can be specified multiple \
times. By default, the email address in the user.email gitconfig(7) variable \
be included

B,boot-args=BOOT-ARGS-FILE    A file containing one BOOT-ARG per line

$(CLI.get_global_blurb)
"

O_FIRMWARES=()
O_BRANCHES=()
O_PLATFORM=
O_VARIANT=
O_SHARED_BASE_TAG=latest
O_HOST=
O_EMAIL_ADDRESSES=(
	"placeholder"
)
O_BOOT_ARGS_FILE=
O_CHIP=

# MARK: Utilities
function derive_machine()
{
	local chip="$O_CHIP"
	local p_suffix=
	local v_suffix=

	if [ -n "$O_PLATFORM" ]; then
		p_suffix="$O_PLATFORM"
	fi

	case "$O_VARIANT" in
	release)
		v_suffix="-release"
		;;
	noasan)
		v_suffix="-noasan"
		;;
	debug)
		v_suffix=
		;;
	esac

	echo "${chip}${p_suffix}${v_suffix}"
}

# MARK: Command Implementation
function __cmd()
{
	local v_arg=$(CLI.get_verbosity_opt "v")
	local target=$(derive_machine)
	local pvmap=(
		"CHIP" "$O_CHIP"
	)
	local i=0
	local imgroot=
	local bug_id=
	local js=
	local branch=

	# Check to see if we're set up for ssh keys on the host. Note that the
	# configuration file sets the username to use for the fun-on-demand cluster.
	CLI.command ssh -vn \
			-o 'PasswordAuthentication no' \
			-o 'BatchMode yes' \
			"$O_HOST" 2>&1 | grep -qE '^Authenticated to'
	if [ $? -ne 0 ]; then
		CLI.warn "bootstrapping authentication to $O_HOST..."

		CLI.command sshauth $v_arg -k "$HOME/.ssh/id_rsa4k.pub" "$O_HOST"
		CLI.die_check $? "authentication failed: $O_HOST"
	fi

	bug_id=$(Branch.guess_primary_problem)
	CLI.die_ifz "$bug_id" "failed to guess branch problem"

	branch=$(Git.get_current_branch)
	CLI.die_ifz "$branch" "failed to get current branch"

	Assembly.init "$target" "${O_FIRMWARES[@]}"
	for (( i = 0; i < ${#pvmap[@]}; i += 2 )); do
		local v="${pvmap[$(( i + 0 ))]}"
		local vv="${pvmap[$(( i + 1 ))]}"

		Assembly.set_variable "$v" "$vv"
	done

	for (( i = 0; i < ${#O_BRANCHES[@]}; i += 2 )); do
		local fw=${O_BRANCHES[$(( i + 0 ))]}
		local b=${O_BRANCHES[$(( i + 1 ))]}

		Assembly.merge_branch "$fw" "$b"
	done

	Assembly.assemble
	CLI.die_check $? "DPU assembly failed"

	imgroot=$(Assembly.get_image_root)
	Fundle.init "$bug_id" "$branch" "$O_CHIP" "$imgroot"
	if [ -n "$O_BOOT_ARGS_FILE" ]; then
		Fundle.set_boot_arg_file "$O_BOOT_ARGS_FILE"
	fi

	for em in "${O_EMAIL_ADDRESSES[@]}"; do
		Fundle.set_email "$em"
	done

	for ba in "$@"; do
		Fundle.set_boot_arg "$ba"
	done

	Fundle.package "signed"
	Fundle.submit "$O_HOST"
}

function __main()
{
	local me="$(basename ${BASH_SOURCE[0]})"
	local email=

	CLI.init "$me" "$GIT_PARSEOPT_SPEC" "$@"
	eval "$(echo "$GIT_PARSEOPT_SPEC" |
		git rev-parse --parseopt --keep-dashdash --stuck-long -- "$@" \
				|| echo exit $?
	)"

	while [ $# -ne 0 ]; do
		local arg="$(CLI.parse_argument "$1")"
		local arg_opt=()
		local fw=
		local fwat=
		local fwb=

		case "$1" in
		-f | --firmware=*)
			arg_opt=($(CLI.split_specifier_nospace '@' "$arg"))
			fw="${arg_opt[0]}"
			fwat="$(initdefault "${arg_opt[1]}" "infer")"

			O_FIRMWARES+=("$fw" "$fwat")
			shift
			;;
		-b | --branch=*)
			arg_opt=($(CLI.split_specifier_nospace ':' "$arg"))
			fw="${arg_opt[0]}"
			fwb="${arg_opt[1]}"
			CLI.die_ifz "$fwb" "invalid branch specifier: $arg"

			O_BRANCHES+=("$fw" "$fwb")
			shift
			;;
		-T | --shared-base-tag=*)
			O_SHARED_BASE_TAG="$arg"
			shift
			;;
		-F | --current-firmware)
			fw="$(Git.get_name)"
			fwat="$(Git.get_branch_base)"
			fwb="$(Git.get_current_branch)"

			O_FIRMWARES+=("$fw" "$fwat")
			O_BRANCHES+=("$fw" "$fwb")
			O_SHARED_BASE_TAG="$fwat"
			shift
			;;
		-p | --platform=*)
			O_PLATFORM="$arg"
			shift
			;;
		-V | --variant=*)
			O_VARIANT="$arg"
			shift
			;;
		-n | --cluster-number=*)
			O_HOST="$arg"
			shift
			;;
		-m | --email-address=*)
			O_EMAIL_ADDRESSES+=("$arg")
			shift
			;;
		-B | --boot-args=*)
			O_BOOT_ARGS_FILE="$arg"
			shift
			;;
		--)
			shift
			break
			;;
		-*)
			# This was one of the common options that was already consumed by
			# the CLI module. git-rev-parse will not have normalized an
			# unrecognized option.
			shift
			;;
		*)
			break
			;;
		esac
	done

	CLI.init_git

	email=$(Git.run config user.email)
	CLI.die_ifz "$email" "no email address in git config"

	# Always include the user's email address first.
	O_EMAIL_ADDRESSES[0]="$email"

	if [ -z "$O_HOST" ]; then
		local x=

		x=$(od -An -tu2 -N2 /dev/urandom | tr -d ' ')
		x=$(( (x % 2) + 1 ))
		O_HOST=$x
	fi

	for (( i = 0; i < ${#O_FIRMWARES[@]}; i += 2 )); do
		local fw=${O_FIRMWARES[$(( i + 0 ))]}
		local fwat=${O_FIRMWARES[$(( i + 1 ))]}

		if [ "$fwat" = "infer" ]; then
			O_FIRMWARES[$(( i + 1 ))]="$O_SHARED_BASE_TAG"
		fi
	done

	O_HOST=$(printf '%02d' "$O_HOST")
	O_HOST="fun-on-demand-$O_HOST"

	if [ $# -lt 1 -o "$1" == "--" ]; then
		CLI.die "must provide a chip"
	fi

	O_CHIP="$1"
	shift

	if [ "$1" == "--" ]; then
		shift
	fi

	__cmd "$@"
}

__main "$@"
